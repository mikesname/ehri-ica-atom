Index: lib/vendor/symfony/lib/plugins/sfPropelPlugin/lib/propel/sfPropelData.class.php
===================================================================
--- lib/vendor/symfony/lib/plugins/sfPropelPlugin/lib/propel/sfPropelData.class.php	(revision 9414)
+++ lib/vendor/symfony/lib/plugins/sfPropelPlugin/lib/propel/sfPropelData.class.php	(working copy)
@@ -46,8 +46,6 @@
     {
       $this->con->begin();
 
-      $this->doDeleteCurrentData($fixtureFiles);
-
       $this->doLoadData($fixtureFiles);
 
       $this->con->commit();
@@ -80,10 +78,8 @@
     {
       $class = trim($class);
 
-      $tableMap = $this->dbMap->getTable(constant($class.'Peer::TABLE_NAME'));
+      $tableMap = $this->dbMap->getTable(constant($class.'::TABLE_NAME'));
 
-      $column_names = call_user_func_array(array($class.'Peer', 'getFieldNames'), array(BasePeer::TYPE_FIELDNAME));
-
       // iterate through datas for this class
       // might have been empty just for force a table to be emptied on import
       if (!is_array($datas))
@@ -101,11 +97,6 @@
 
         $obj = new $class();
 
-        if (!$obj instanceof BaseObject)
-        {
-          throw new RuntimeException(sprintf('The class "%s" is not a Propel class. This probably means there is already a class named "%s" somewhere in symfony or in your project.', $class, $class));
-        }
-
         if (!is_array($data))
         {
           throw new InvalidArgumentException(sprintf('You must give a name for each fixture data entry (class %s).', $class));
@@ -113,58 +104,41 @@
 
         foreach ($data as $name => $value)
         {
-          // will need to be updated for Propel 1.3
-          if (is_array($value) && 's' == substr($name, -1))
-          {
-            // many to many relationship
-            $this->loadMany2Many($obj, substr($name, 0, -1), $value);
-
-            continue;
-          }
-
-          $isARealColumn = true;
           try
           {
             $column = $tableMap->getColumn($name);
           }
           catch (PropelException $e)
           {
-            $isARealColumn = false;
           }
 
           // foreign key?
-          if ($isARealColumn)
+          if (isset($column) && $column->isForeignKey() && isset($this->object_references[$value]))
           {
-            if ($column->isForeignKey() && !is_null($value))
+            $value = $this->object_references[$value]->getPrimaryKey();
+          }
+
+          if (is_callable(array($obj, $callback = 'set'.sfInflector::camelize($name))))
+          {
+            if (is_array($value))
             {
-              $relatedTable = $this->dbMap->getTable($column->getRelatedTableName());
-              if (!isset($this->object_references[$relatedTable->getPhpName().'_'.$value]))
+              foreach ($value as $culture => $value)
               {
-                throw new InvalidArgumentException(sprintf('The object "%s" from class "%s" is not defined in your data file.', $value, $relatedTable->getPhpName()));
+                call_user_func(array($obj, $callback), $value, array('culture' => $culture));
               }
-              $value = $this->object_references[$relatedTable->getPhpName().'_'.$value]->getPrimaryKey();
             }
+            else
+            {
+              call_user_func(array($obj, $callback), $value);
+            }
           }
-
-          if (false !== $pos = array_search($name, $column_names))
-          {
-            $obj->setByPosition($pos, $value);
-          }
-          else if (is_callable(array($obj, $method = 'set'.sfInflector::camelize($name))))
-          {
-            $obj->$method($value);
-          }
-          else
-          {
-            throw new InvalidArgumentException(sprintf('Column "%s" does not exist for class "%s".', $name, $class));
-          }
         }
         $obj->save($this->con);
 
         // save the object for future reference
         if (method_exists($obj, 'getPrimaryKey'))
         {
-          $this->object_references[$class.'_'.$key] = $obj;
+          $this->object_references[$key] = $obj;
         }
       }
     }
@@ -338,12 +312,21 @@
       $tables = array($tables);
     }
 
+    // Maintain an index of foreign keys to class names, e.g. QubitActor_123 =>
+    // QubitRepository.  This is used in the case of multi-table inheritance to
+    // build symbolic foreign keys which refer to the primary class of an
+    // object.  This is important because the dump data contains entries only
+    // for the primary classes of objects.  Another alternative would be to
+    // resolve symbols when the data is loaded, by creating an entry in the
+    // symbol table for each of an object's subclasses.
+    $classNames = array();
+
     $dumpData = array();
 
     $tables = $this->fixOrderingOfForeignKeyData($tables);
     foreach ($tables as $tableName)
     {
-      $tableMap = $this->dbMap->getTable(constant($tableName.'Peer::TABLE_NAME'));
+      $tableMap = $this->dbMap->getTable(constant('Qubit'.$tableName.'::TABLE_NAME'));
       $hasParent = false;
       $haveParents = false;
       $fixColumn = null;
@@ -382,65 +365,110 @@
       }
       else
       {
-        $resultsSets[] = $this->con->executeQuery('SELECT * FROM '.constant($tableName.'Peer::TABLE_NAME'));
+        $resultsSets[] = $this->con->executeQuery('SELECT * FROM '.constant('Qubit'.$tableName.'::TABLE_NAME'));
       }
 
       foreach ($resultsSets as $rs)
       {
-        if($rs->getRecordCount() > 0 && !isset($dumpData[$tableName])){
-          $dumpData[$tableName] = array();
-        }
-
         while ($rs->next())
         {
-          $pk = $tableName;
+          // Initialize the class name for each row because each row may have a
+          // different primary class
+          $className = 'Qubit'.$tableName;
+
+          $foreignKeys = array();
+          $primaryKeys = array();
           $values = array();
-          $primaryKeys = array();
-          $foreignKeys = array();
 
           foreach ($tableMap->getColumns() as $column)
           {
             $col = strtolower($column->getColumnName());
-            $isPrimaryKey = $column->isPrimaryKey();
 
-            if (is_null($rs->get($col)))
+            if (null === $rs->get($col))
             {
               continue;
             }
 
-            if ($isPrimaryKey)
+            // Hack: Rely on an explicitly named 'class_name' column of the
+            // base class for multi-table inheritance
+            if ($col == 'class_name')
             {
-              $value = $rs->get($col);
-              $pk .= '_'.$value;
-              $primaryKeys[$col] = $value;
+              $className = $rs->get($col);
             }
 
             if ($column->isForeignKey())
             {
               $relatedTable = $this->dbMap->getTable($column->getRelatedTableName());
-              if ($isPrimaryKey)
+
+              // If we are a subclass of the foreign table, then a foreign
+              // row will be inserted when we are created.  Merge the foreign
+              // values into our values to avoid inserting two rows.
+              if ($column->isPrimaryKey() && is_subclass_of($className, 'Qubit'.$relatedTable->getPhpName()))
               {
-                $foreignKeys[$col] = $rs->get($col);
-                $primaryKeys[$col] = $relatedTable->getPhpName().'_'.$rs->get($col);
+                $className = $classNames['Qubit'.$relatedTable->getPhpName().'_'.$rs->get($col)];
+
+                $values += $dumpData[$className][$className.'_'.$rs->get($col)];
               }
               else
               {
-                $values[$col] = strlen($rs->get($col)) ? $relatedTable->getPhpName().'_'.$rs->get($col) : '';
+                // Build symbolic foreign keys using the primary class of the
+                // related object
+                $foreignKeys[$col] = $classNames['Qubit'.$relatedTable->getPhpName().'_'.$rs->get($col)].'_'.$rs->get($col);
               }
             }
-            elseif (!$isPrimaryKey || ($isPrimaryKey && !$tableMap->isUseIdGenerator()))
+
+            if ($column->isPrimaryKey())
             {
-              // We did not want auto incremented primary keys
+              $primaryKeys[$col] = $rs->get($col);
+
+              // Note: Reuse of $relatedTable outside the above if statement.
+              // Consequently it must follow !$column->isForeignKey() ||
+              if (!$column->isForeignKey() || is_subclass_of('Qubit'.$tableName, 'Qubit'.$relatedTable->getPhpName()))
+              {
+                // Set primary keys to explicit values only if the value matches
+                // a constant defined by the corresponding class.  We use the
+                // first constant whose value matches the value of the primary
+                // key.  This is not a rigorous test.
+                $class = new ReflectionClass('Qubit'.$tableName);
+                $constants = array_flip($class->getConstants());
+                if (isset($constants[$rs->get($col)]))
+                {
+                  // Use a custom ReflectionCode class for wrapping PHP code.
+                  // Otherwise it is impossible to distinguish code strings from
+                  // literal strings.  If the PHP reflection API supported a
+                  // ReflectionConstant, we might be able to use that:
+                  // http://ca.php.net/manual/en/language.oop5.reflection.php#82383
+                  //
+                  // Instead, we use our custom, more general class for
+                  // representing PHP code.
+                  $values[$col] = new ReflectionCode('echo Qubit'.$tableName.'::'.$constants[$rs->get($col)].'."\n"');
+                }
+              }
+            }
+
+            if (!$column->isForeignKey() && !$column->isPrimaryKey())
+            {
               $values[$col] = $rs->get($col);
             }
           }
 
-          if (count($primaryKeys) > 1 || (count($primaryKeys) > 0 && count($foreignKeys) > 0))
+          // Roll i18n values into an array in the non-i18n object, for clarity
+          if (substr($tableName, -4) == 'I18n')
           {
-            $values = array_merge($primaryKeys, $values);
+            foreach ($values as $key => $value)
+            {
+              // Dirty hack: Reuse last value of $relatedTable outside columns
+              // loop.  This works because i18n tables are related to exactly
+              // one other table.
+              $dumpData[$classNames['Qubit'.$relatedTable->getPhpName().'_'.$primaryKeys['id']]][$foreignKeys['id']][$key][$primaryKeys['culture']] = $value;
+            }
           }
+          else
+          {
+            $classNames['Qubit'.$tableName.'_'.implode('_', $primaryKeys)] = $className;
 
-          $dumpData[$tableName][$pk] = $values;
+            $dumpData[$className][$className.'_'.implode('_', $primaryKeys)] = $foreignKeys + $values;
+          }
         }
       }
     }
@@ -459,7 +487,7 @@
     for ($i = 0, $count = count($classes); $i < $count; $i++)
     {
       $class = $classes[$i];
-      $tableMap = $this->dbMap->getTable(constant($class.'Peer::TABLE_NAME'));
+      $tableMap = $this->dbMap->getTable(constant('Qubit'.$class.'::TABLE_NAME'));
       foreach ($tableMap->getColumns() as $column)
       {
         if ($column->isForeignKey())
@@ -491,7 +519,7 @@
   protected function fixOrderingOfForeignKeyDataInSameTable($resultsSets, $tableName, $column, $in = null)
   {
     $rs = $this->con->executeQuery(sprintf('SELECT * FROM %s WHERE %s %s',
-      constant($tableName.'Peer::TABLE_NAME'),
+      constant('Qubit'.$tableName.'::TABLE_NAME'),
       strtolower($column->getColumnName()),
       is_null($in) ? 'IS NULL' : 'IN ('.$in.')'
     ));
